{% meta %}
    tags: [retellings, faq, python]
    title: Python 3000 FAQ
{% endmeta %}

{% mark body %}
Это перевод <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=211200">двух</a> <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=211430">постов</a> Гвидо, где он отвечает на часто задаваемые ему вопросы о Python 3000.



<!--more-->

<p><strong>Я хочу изучать Python. Мне следует начинать с Python 2.6 или Python 3.0?</strong>
</p>
<p>Определенно, стоит начинать с Python 2.x (последняя вышедшая версия - 2.5). Я полагаю что в действительности следует изучать Python 3.0 через пару лет, тем более с точки зрения начинающего различия не такие большие: большинство того, что вы узнаете о 2.x будет таким же и в 3.0.
</p>
<p><strong>Если убрали <code>reduce()</code>, почему оставили <code>map()</code> и <code>filter()</code>?</strong>
</p>
<p>Я убрал <code>reduce()</code> не потому что я ненавижу функциональный подход, а потому что большинство кода с <code>reduce()</code> менее читабельно, чем то же самое, переписанное с циклом <code>for</code> и промежуточной переменной. С другой стороны, <code>map()</code> и <code>filter()</code> часто бывают полезны и когда они используются с уже существующей функцией (т.е. встроенной), то более прозрачны, чем списковые выражения или выражения-генераторы. (Не используйте их вместе с <code>lambda</code>; в этом случае предпочтительней и быстрее списковые выражения.)
</p>
<p><strong>В ближайшем будующем многоядерные процессоры будут обычным делом и на ноутбуках. Избавится ли Python 3.0 от GIL (Global Interpreter Lock) для того чтобы использовать преимущества многоядерности?</strong>
</p>
<p>Нет. Мы не настолько сильно меняем реализацию CPython. Для того, чтобы избавиться от GIL нужно практически полностью переписать интерпретатор, поскольку все внутренние структуры данных (и операции подсчета ссылок) должны быть thread-safe. Как то (в конце 90-х, Грег Стайн) уже была попытка и в результате интерпретатор стал вдвое медленней. Если у вас несколько CPU и вы желаете использовать каждый из них, то создавайте столько процессов, сколько у вас процессоров. (Вы же пишите легко масштабируемые веб-приложения, не так ли? Так если есть возможность запустить несколько копий на нескольких машинах, то задача запуска нескольких копий на одной машине тривиальна.). Если Вам действительно нужна &quot;честная&quot; многопоточность в Python, используйте Jython или IronPython; JVM и CLR имеют поддержку многопроцессорных потоков. Конечно, будьте готовы к взаимным блокировкам, livelock, race condition и всем другим &quot;прелестям&quot;, сопровождающим многопоточный код.
</p>
<p><strong>Я бы предпочел использовать один и тот же код для 2.x и 3.0; я очень не хочу использовать 2to3 для преобразования кода. Почему бы не обойтись без этого?</strong>
</p>
<p>Как угодно. 2.6 и 3.0 сильно пересекаются, но есть некоторые вещи, которые не получатся: Вам нельзя использовать ни Unicode-строки (есть только в 2.6), ни байтовые строки (есть только в 3.0). Единственный общий синтаксис для <code>print</code> -- это <code>print(x)</code>. Когда вы перехватываете исключение, то у вас нет возможности исследовать ее аргумент, поскольку в 2.6-синтаксисе используется запятая, а в 3.0 -- <code>as</code>. Не получится использовать <code>.iterkeys()</code>, но <code>.keys()</code> можно (хотя работает по-разному в 2.6 и 3.0). И т.д. Ограничение себя только лишь пересечением двух версий неудобно и не всегда возможно. Мы не заявляем обратной совместимости в 3.0, поскольку изначально не было такой цели (мы сохраняем обратную совместимость для всех версий 2.x, так что 3.0 -- это &quot;уборка мусора&quot;).
</p>
<p><strong>Будет ли в Python 3000 возможность X (еще не рассмотренная)?</strong>
</p>
<p>Нет. Дедлайн для добавления возможностей (PEP'ов) был 30-го апреля 2007. Я выделю некоторые из них для пояснения, почему различные идеи (большинство из которых не новы) не рассмотрены или отклонены.
</p>
<p><strong>Будет ли удалена в Python 3000 неявная конкатенация строк? (т.е., вместо (&quot;a&quot; &quot;b&quot;) нужно будет писать (&quot;a&quot; + &quot;b&quot;).)</strong>
</p>
<p>Нет. Это было рассмотрено в <a href="http://www.python.org/dev/peps/pep-3126/">PEP 3126</a> и отклонено.
</p>
<p><strong>Будет ли в Python 3000 стандартизирован бинарный API для строк? (в зависимости от условий времени компиляции, юникод-строки могут быть как 2-х байтными, так и 4-х байтными.)</strong>
</p>
<p>Нет, существуют веские причины для поддержки 2 байтов в одном случае и 4 в другом. Обычно это обходится компилированием исходных текстов используя заголовочные файлы уже установленного Python.  Если это не работает и вы обеспокоены этим, я бы посоветовал обратиться в список рассылки python-3000 и объяснить свою позицию.
</p>
<p><strong>Почему GIL (Global Interpreter Lock) не рекурсивен?</strong>
</p>
<p>Несколько причин. Рекурсивные блокировки более дороги, а GIL используется <em>очень часто</em>. Python-пакет <code>thread</code>, написанный на C, не реализует рекурсивные блокировки (это просто добавление на Python, см. <code>RLock</code> в <code>threading.py</code>. ) Ввиду различия API потоков на различных платформах, крайне важно что C-код, завязанный на потоках, был минимален. Но, по видимому, самая серъезная причина такова: GIL часто <em>освобождается</em> около операций ввода-вывода. Освобождение только одного уровня рекурсивной блокировки в данном случае не корректно; кто-нибудь захочет освободить низлежащую нерекурсивную блокировку и восстановить уровень рекурсии после перезахвата. Всё это достаточно закручено. С нерекурсивной блокировкой всё это делается намного проще.
</p>
<p><strong>Будет ли в Python 3000 возможность использовать операторы в <code>lambda</code>?</strong>
</p>
<p>Нет. Синтаксис (отступы внутри выражения) будет сложен как для реализации, так и для чтения. Я рекомендую просто определять <em>локальную</em> (т.е. вложеннную) функцию --- она имеет ту же семантику как <code>lambda</code>, но без синтаксических ограничений. Итак,
</p>
<pre><code>foo = lambda: whatever
</code></pre><p><em>полностью</em> эквивалентно:
</p>
<pre><code>def foo(): return whatever
</code></pre><p>(кроме разве того, что <code>lambda</code> &quot;не помнит&quot; своего имени).
</p>
<p><strong>В Python 3000 нужна хвостовая оптимизация?</strong>
</p>
<p>Нет. Аргумент таков: то, что это будет &quot;прозрачной&quot; оптимизацией -- не верно, она приводит к изменению стиля, зависимого от хвостовой оптимизации, так что в этом ключе прозрачность теряется. И вообще, почему <em>нужна</em>? :-) Еще, будет сложнее читать трейсбеки. Реальность такова, что Python -- <em>не</em> функциональный язык. Функциональщина работает в большей степени на сторонних эффектах изменяемых объектов, и не будет возможности преобразовывать программу, сохраняя семантику.
</p>
<p><strong>Python 3000 будет предоставлять &quot;настоящие&quot; private, protected и public?</strong>
</p>
<p>Нет. Python будет оставаться языком &quot;открытого кимоно&quot;.
</p>
<p><strong>Python 3000 будет поддерживать статическую типизацию?</strong>
</p>
<p>Не так, а то язык станет Java-без-скобок. Тем не менее, вы можете использовать &quot;аннотации аргументов&quot; (<a href="http://www.python.org/dev/peps/pep-3107/">PEP 3107</a>, см. также <a href="http://softwaremaniacs.org/blog/2007/06/19/python-3000-function-annotations/">пост Ивана Сагалаева</a>) и написать декоратор или метакласс для типизации аргументов во время выполнения. Я полагаю, что вполне можно написать расширение к <a href="http://pychecker.sourceforge.net/">pychecker</a> или <a href="http://www.logilab.org/857">pylint</a>, которые бы проверяли сигнатуры функций, используя аннотации.
</p>
<p><strong>Почему <code>str(c for c in X)</code> не возвращает &quot;склеенную&quot; строку значений c?</strong>
</p>
<p>Что ж, будем последовательны, <code>str(['a', 'b', 'c'])</code> будет возвращать <code>'abc'</code>. Это немного не то, что вы хотели бы. Далее, что будет делать <code>str([1, 2, 3])</code>? И это будет большой проблемой, если <code>str()</code> будет вызывать исключение, поскольку это означает невозможность печати аргумента: <code>print</code> вызывает <code>str()</code> для каждого аргумента.
</p>
{% endmark %}
