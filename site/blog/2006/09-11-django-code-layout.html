{% meta %}
    tags: [retellings, docs, django]
    title: Организация кода в Django-проекте
{% endmeta %}

{% mark body %}
<a href="http://www.b-list.org/weblog/2006/09/10/django-tips-laying-out-application">Джеймс Бенетт написал такую статью</a>, что ее можно смело и настойчиво рекомендовать к прочтению всем разработчикам, использующим Django. В первую очередь это касается тех, кто только начал знакомиться с этим фреймворком. Мне так понравилась статья, что я не стал ее пересказывать, а перевел полностью.

<!--more-->

<em>Я не стал обрамлять ее в blockquote, но Вам, надеюсь, и так понятно, что местоимение "я" следует заменять на "Джеймс Бенетт", а не на "автор блога".</em>

<p>Продолжаем тему вопросов общего характера из списка почтовой рассылки и IRC канала. Сегодня мы рассмотрим как организовать некоторые вещи в Django-проекте или приложении.
</p>

<h2>Проекты vs. приложения</h2>
<p>На самом деле, это два отдельных вопроса (хотя и близких по смыслу), но понимание различий в Django между &quot;проектом&quot; (project) и &quot;приложением&quot; (application) - большой шаг к хорошей структуре кода. Грубо говоря, вот что означают эти термины:
</p>
<ul>
 <li>

     <em>Приложение</em> пытается предоставить единый, в некоторой степени самодостаточный, набор функций. Приложению позволено определять набор моделей (хотя может и не делать этого); определять и регистрировать свои шаблонные теги и фильтры (хотя, опять-таки, может и не делать).
 </li>

 <li>
     <em>Проект</em> - это совокупность приложений, установленных в одной и той же базе данных, и использующих один и тот же файл настроек. В некотором смысле, определение проекта - <em>в том</em>, что он предоставляет файл настроек, в котором указывается, какую базу данных использовать, какие приложения устанавливать и другие параметры конфигурации. Проект <em>может</em> соответствовать одному веб-сайту, но может и не соответствовать - несколько проектов могут обслуживать один сайт. Проект также отвечает за настройки корневого URL, хотя в большинстве случаев достаточно того, что он &quot;подключает&quot; настройки URL из отдельных приложений.
 </li>

</ul>
<p>Виды (view), свои манипуляторы (manipulator), свои обработчики контекста (context processor) и большинство других вещей, которые Django позволяет создавать, могут быть определены как на уровне проекта, так и на уровне приложения. Вы должны определять их там, где Вам удобней, хотя, в целом, лучше, если они определены внутри приложения (это улучшает его переносимость между проектами).
</p>

<h2>Структура файлов по умолчанию на уровне проекта</h2>
<p>Когда Вы выполняете <code>django-admin.py startproject</code>, Django автоматически создает новый каталог, содержащий четыре файла:
</p>
<ul>
 <li>
     <code>__init__.py</code>, пустой. Этот файл необходим для того, чтобы Python интерпретировал этот каталог как Python-модуль.
 </li>

 <li>
     <code>manage.py</code> предоставляет удобные функции для управления и работы с проектом.
 </li>

 <li>
     <code>settings.py</code> является файлом настроек проекта.
 </li>

 <li>
     <code>urls.py</code> является файлом настроек корневого URL проекта
 </li>
</ul>
<p>Вообще говоря, у Вас нет необходимости изменять эту структуру, и для совместимости и последовательности лучше этого не делать. Если у Вас всё же есть желание изменить эту структуру, то вот, что можно делать без опаски:
</p>
<ul>
 <li>
     Вы можете сохранить настройки в файле, который не называется <code>settings.py</code> - Django найдет Ваши настройки, посмотрев значение переменной окружения <code>DJANGO_SETTINGS_MODULE</code>
 </li>

 <li>
     Вы можете сохранить настройки корневого URL в другом месте, помимо <code>urls.py</code> - Django смотрит параметр <code>ROOT_URLCONF</code> для поиска места, где находятся настройки URL.
 </li>
</ul>

<h2>Структура файлов по умолчанию на уровне приложения</h2>
<p>Когда Вы запускаете <code>manage.py startapp</code>, Django создает подкаталог в каталоге Вашего проекта и в нем создает следующие файлы:
</p>

<ul>
 <li>
     <code>__init__.py</code> служит тем же целям, что и аналогичный файл в директории проекта
 </li>

 <li>
     <code>models.py</code> является модулем, в котором находятся классы моделей приложения
 </li>

 <li>
     <code>views.py</code> является модулем, в котором находятся виды, используемые в приложении.
 </li>
</ul>
<p>Файлы <code>__init__.py</code> и <code>models.py</code> (или, конечно, если Вы захотите разделить модели по нескольким файлам, каталог с именем <code>models</code>, который будет действовать как модуль Python) необходимы. Без <code>__init__.py</code> Python не сможет импортировать приложение. В Django &quot;намертво&quot; зашито, что модели нужно искать либо в модуле <code>models</code>. Файл <code>views.py</code> опционален и Вы можете удалить его, если нет специфичных для приложения видов, либо переименовать его в нечто иное (хотя в целях последовательности лучше не переименовывать).

</p>

<h2>Экстра-фишки</h2>
<p>Существует четыре &quot;специальных&quot; места в приложении, которые используются специфичными &quot;фишками&quot;, так что если Вы желаете воспользоваться этими &quot;фишками&quot;,то у Вас нет выбора куда их вставлять:
</p>
<ol>
 <li>
     Для определения своих шаблонных тегов или фильтров, Вы должны создать подкаталог <code>templatetags</code> в каталоге приложения; этот каталог должен содержать файл <code>__init__.py</code> (чтобы Python смог подкаталог &quot;воспринимать&quot; как модуль). Далее, Вы определяете свои теги и фильтры в файлах, которые имеют любое имя по Вашему усмотрению. Если в каталоге <code>templatetags</code> у Вас есть файл, скажем <code>mytags.py</code>, то в шаблонах Вы можете подгружать этот файл <code>{{ '{%' }} load mytags {{ '%}' }}</code> для получения доступа к тегам или фильтрам, которые определены в нем.
 </li>

 <li>
     Для определения юнит-тестов, которые автоматически будут подключены к тест-каркасу (testing framework) Django, поместите их в модуль <code>tests</code> (это может быть файл <code>tests.py</code>, либо каталог <code>tests</code>). Тест-каркас также найдет все doctest'ы в этом модуле, но предпочтительное место для них - конечно docstring'и соответствующих классов или функций.
 </li>

 <li>
     Для того, чтобы указать свои SQL-запросы, которые будут выполнены сразу после установки приложения, Вы должны в каталоге приложения создать подкаталог <code>sql</code>; имена файлов должны быть такими же, как имена моделей, чьи таблицы эти запросы обрабатывают. Например, если у Вас есть приложение <code>weblog</code>, в котором есть модель <code>Entry</code>, файл <code>sql/Entry.sql</code> внутри каталога приложения может быть использован для модификации либо вставки данных в таблицу <code>entries</code> сразу после ее создания.
 </li>

 <li>
     Для того, чтобы указать свои Python-функции, которые будут выполнены сразу после установки приложения, Вы должны поместить их в файл <code>management.py</code> и использовать внутренний диспетчер Django для соединения ваших функций с сигналом <code>post_syncdb</code>.
 </li>
</ol>
<p>Последний пункт требует пояснений, так что рассмотрим его чуть подробней.
</p>
<p>Внутри Django для коммуникаций между составными его частями используется пакет <a href="http://pydispatcher.sourceforge.net/">PyDispatcher</a>. Диспетчер работает примерно так:

</p>
<ol>
 <li>
     Различные части Django, равно как и другие приложения, определяют простые объекты, называемые &quot;сигналами&quot;
 </li>

 <li>
     Код, который хочет сообщить о происходящем, просит диспетчера послать определенный сигнал.
 </li>

 <li>
     Код, который хочет получать информацию о происходящем, использует метод диспетчера <code>connect</code> для того, чтобы слушать определенный сигнал.
 </li>
</ol>
<p>Например, если у Вас есть желание написать функцию, которая будет выполняться каждый раз при установке нового приложения, Вы можете создать файл <code>management.py</code> внутри приложения и поместить в него следующий код:
</p>
<pre><code>from django.dispatch import dispatcher
from django.db.models import signals

def my_syncdb_func():
    # put your code here...

dispatcher.connect(my_syncdb_func, signal=signals.post_syncdb)
</code></pre><p>Некоторые приложения, идущие в поставке с Django, используют этот трюк для различных вещей:
</p>

<ul>
 <li>
     <code>django.contrib.sites</code> ожидает момента своей установки, после чего создает начальный объект сайта &quot;example.com&quot;, необходимый для функционирования &quot;админки&quot;.
 </li>

 <li>
     <code>django.contrib.contenttypes</code> ожидает момента установки любого нового приложения, после чего создает новых представителей класса <code>ContentType</code> для всех установленных моделей.
 </li>

 <li>
     <code>django.contrib.auth</code> работает на два фронта: после установки приложения <code>auth</code>, он спрашивает о создании суперпользователя, а после установки любого другого приложения, создает права доступа для моделей этого приложения.
 </li>
</ul>
<p>Эти вещи работают, поскольку функция <code>syncdb</code> в <code>manage.py</code> импортирует файлы <code>management.py</code> из всех установленных и вскоре-будут-установлены приложений Вашего проекта; это дает уверенность, что любому приложению будет дана возможность воспользоваться диспетчером.

</p>

<h2>Другие полезные соглашения</h2>
<p>Конечно, этот текст не перекрывает всего, что Вы возможно захотите сделать с Django, но большинство людей останавливается на желании узнать, как им следует организовать свой код. Вообще говоря, нет строгих требований следовать стандартному расположению кода, но полезно придерживаться некоторых соглашений. Так что приведу пример, как я обычно размещаю дополнительные компоненты в тех проектах, над которыми работаю.
</p>
<p>На уровне проекта я обычно мало чего добавляю: чаще то, что мне требуется лучше вписывается на уровне приложения. Те не менее, если у Вас запущено несколько проектов, и каждый из них использует все или почти все одинаковые приложения, то весьма полезно тщательно выбирать настройки. Джейкоб пару раз упоминал трюк, который мы использовали в Journal-Worlds, и я думаю, он довольно полезен: весь наш код находится в одной структуре директорий, а файлы настроек - в другой, с &quot;умолчательным&quot; файлом настроек в корне дерева настроек. Файлы настроек для отдельного сайта импортируют &quot;умолчательные&quot; настройки и переопределяют либо добавляют нужные. Поскольку Django не требует, чтобы файлы настроек находились в том же дереве каталогов, что и проекты, использующие эти настройки, то это очень просто и весьма полезно.
</p>
<p>На уровне приложения я обычно добавляю несколько файлов, в зависимости от того, над чем конкретно я работаю:
</p>
<ul>
 <li>
     Если в приложении определяются какие-либо манипуляторы, я помещаю их в файл <code>forms.py</code>, а не в файл видов.
 </li>
 <li>
     Если в приложении нужно несколько своих менеджеров, я помещаю их в файл <code>managers.py</code> вместо файла моделей.
 </li>
 <li>
     Если я определяю свои обработчики контекста, я помещаю их в файл <code>context_processors.py</code>.
 </li>
 <li>
     Если я определяю свои сигналы для диспетчера, то они лежат в <code>signals.py</code>.
 </li>
 <li>
     Если приложение использует синдикат-ленты (syndication feed), то классы для лент лежат в <code>feeds.py</code>.
 </li>
 <li>
     Классы-посредники помещаю в <code>middleware.py</code>, аналогично классы карт сайта лежат в <code>sitemaps.py</code>.
 </li>
 <li>
     Другой код, который не вписывается ни во что другое, помещаю в пакет <code>utils</code>.
 </li>
</ul>
<p>Я не всегда использую весь перечисленный функционал в приложении, но если использую, то приятно иметь соглашение по размещению, так что мне достаточно запомнить <code>from appname import forms</code> или <code>from appname import feeds</code>.
</p>

<h2>И еще одно замечание...</h2>
<p>Это то, над чем я еще работаю: у меня есть желание найти простой способ тестировать зависимости моего приложения и проверять, что все верно сконфигурировано. Самый простой способ, по моему опыту, это положить некоторый код с необходимыми проверками в <code>__init__.py</code> приложения. Я написал <a href="http://groups.google.com/group/django-developers/browse_thread/thread/5dba01e46461fad/#hdropenedbe076ab6855b9b9f">простой пример в письме</a> в список рассылки разработчиков Django и я все еще работаю над улучшением; есть несколько функций, припрятанных в <code>django.core.management</code>, эти функции позволяют не только проверить, что приложение может быть импортировано и что оно указано в параметре <code>INSTALLED_APPS</code>, но и проверить, установлено ли приложение в базу данных.

</p>

<h2>А как Вы делаете?</h2>
<p>Похоже, я изложил все, что знаю, указал все используемые трюки для прозрачной структуры приложения или проекта Django. Если Вы увидите что-то, что Вам по душе, Вы можете спокойно использовать это. И если я что-то не упомянул, что знаете Вы, то, пожалуйста, напишите комментарий и пусть все об этом узнают :)
</p>
{% endmark %}
