{% meta %}
    tags: [django, testing, nose]
    title: Внешние инструменты тестирования для Django
{% endmeta %}

{% mark body %}
<p>Кому-то хватает <a href="http://docs.djangoproject.com/en/dev/topics/testing/">стандартных инструментов тестирования Django</a>,
кому-то нет. Мне стандартного мало и я сделал обзор сторонних инструментов
тестирования в Django.</p>
<p>В обзор попали:</p>
<ul><li><a href="http://devel.almad.net/trac/django-sane-testing/">django-sane-testing</a></li><li><a href="http://github.com/ericholscher/django-test-utils/">django-test-utils</a></li><li><a href="http://bitbucket.org/mtrichardson/django_satprep/">django-satprep</a></li><li><a href="http://bitbucket.org/miracle2k/djutils/">djutils.test</a></li><li><a href="http://www.assembla.com/wiki/show/nosedjango">nosedjango</a></li><li><a href="http://github.com/playpauseandstop/tddspry/">tddspry</a></li></ul>

<!--more-->

<p>Самое забавное, что я опросил уважаемых мною знакомых "джангонавтов", и оказалось, что народ в большинстве своём удовлетворяется стандартными <code>django.test.TestCase</code> и <code>django.test.Client</code></p>.

<h3>Django sane testing</h3>

<p>Sane testing закрепляет стратегию тестирования "нужна БД -- <code>django.test.TestCase</code>, можно обойтись без БД -- <code>unittest.TestCase</code>" и делает ее более явной. Sane testing предоставляет базовые классы для тестирования в стиле xUnit в следующих вариациях:</p>
<ul><li>если тестовая БД не требуется, то <code>UnitTestCase</code></li><li>если требуется тестовая БД, но каждый тест можно "обернуть" транзакцией и
после успешного выполнения теста эту транзакцию откатить -- <code>DatabaseTestCase</code>
(сюда же относятся и тесты, использующие <code>django.test.Client</code>)</li><li>если нужна тестовая БД и тесты используют транзакции (в этом случае, БД
сбрасывается для каждого теста) -- <code>DestructiveDatabaseTestCase</code></li><li>если для тестов нужен http-сервер (например, для проверки http basic/digest
аутентификации) -- то <code>HttpTestCase</code> (он же является и деструктивным для БД)</li><li>для функциональных тестов при помощи Selenium RC -- <code>SeleniumTestCase</code></li></ul>

<h3>Django test utils</h3>
<p>Django-test-utils примечателен оригинальными идеям, однако реализация хромает. Первым, чем выделяются test utils -- генератор функциональных тестов.
Вы запускаете <code>manage.py testmaker</code>, запускается обычный dev-http сервер, ходите по ссылкам, а testmaker записывает ваши действия. Потом вы
останавливаете dev-http сервер и вуаля -- у вас есть сгенерированные тесты.
Идея хороша. Для twill есть инструменты генерирования тестов, но не нативные,
а использующие более общие генераторы веб-тестов. Для Selenium есть родные
инструменты подготовки тестов "натыкиванием", но сам Selenium, IMHO, не очень
удобно запускать (по крайней мере, в Django-инфраструктуре). Но тесты, которые
создает testmaker, мне не особо понравились: и стиль кода выпадает (например,
там для отступов используется tab), и сами тесты (в содержательной части)
мне не особо понравились.</p>
<p>Дальше больше и test utils предоставляют еще один интересный инструмент --
краулер. Он считывает urlconf, потом ходит по объявленным ссылкам (с опциональной
возможностью записывать время отклика) и отчитывается, на какие урлы из urlconf
он ни разу не ходил. Бывает полезно ;)</p>
<p>На этом дело не заканчивается, и test utils еще дают небольшую интеграцию
Django и twill, взятую у djutils.test. Правда, взята бездарно, потому
что testmaker не умеет генерировать тесты для <a href="http://twill.idyll.org/">twill</a>.</p><p>В целом, у меня создалось впечатление, что эти же идеи можно было реализовать
намного более удачно и получить шикарный инструмент. Ну а пока, это
разношерстный набор оригинальных интересных инструментов, обязательных
к просмотру, а вот к использованию... по крайней мере я не решился.</p>

<h3>Django satprep</h3>
<p>Django satprep минималистичен: это nose test runner (<a href="http://blog.jeffbalogh.org/post/57653515/nose-test-runner-for-django">взятый из basie</a>) и небольшой полезный модуль для nose+twill, делающий преднастройку WSGI intercept. В двух словах: идея WSGI intercept в том, что для функционального тестирования используется не полноценный http-клиент и http-сервер, а как конечная цель тестирования используется WSGI приложение.</p>

<h3>djutils.test</h3>
<p>Djutils -- эта куча всякого Django-related кода. Я не стал толком рассматривать
все его фичи, а сконцентрировался на тестировании, так что рассматриваем дальше
только djutils.test. Выше этот пакет уже упоминался, как оригинальное место,
откуда заимствована интеграция Django и twill. Интеграция заключается в</p>
<ol><li>По сайту можно ходить по относительным ссылкам, так что не нужно
привязываться к хосту и порту для twill</li><li>Возможность использовать reverse-resolving вместе урлов</li><li>Возможность для аутентификации давать экземпляр <code>django.contrib.auth.User</code></li></ol>
<p>Из оставшихся фич: nose test runner (своя реализация) и py.test runner.</p>
<p>В целом, мне djutils не приглянулся, с миру по нитке, собственный стиль кода,
который мне не особо понравился, отсутствие какой-либо документации... В общем,
не очень хорошее впечатление.</p>
<h3>NoseDjango</h3>
<p>В NoseDjango применен метод "от противного". Большинство проектов используют
возможности Django для применения кастомных test runner'ов. NoseDjango
наоборот, использует расширяемость nose и реализован в виде nose-плагина.
Инсталляция NoseDjango добавляет в <code>nosetests</code> опцию <code>--with-django</code> и
настраивает тестовое окружения Django перед запуском тестов. В принципе,
работает как заявлено, но мне пока что больше нравится запускать джанговские
тесты при помощи <code>python manage.py test</code>, хотя может и этот плагин распробую...</p>

<h3>tddspry</h3>
<p>Подход <a href="http://djangonaut.blogspot.com/2009/04/test-or-die.html">tddspry</a> напоминает подход Django sane testing -- явно разделенные базовые классы тестов:</p>
<ul><li><code>NoseTestCase</code> -- полная аналогия <code>unittest.TestCase</code>, не использует БД</li><li><code>DatabaseTestCase</code> -- тесты, которым нужны БД</li><li><code>HttpTestCase</code> -- twill-тесты, также есть кое-какие хелперы.</li></ul>
<p>В общем и целом, создалось впечатление "почти django sane testing с twill
вместо selenium".</p>

<h3>Что я выбрал и почему</h3>
<p>Когда я начинал делать обзор, я искал инструмент, который позволил бы мне:</p>
<ol><li>Использовать уже написанные тесты, которые на момент анализа запускались
<code>python manage.py test</code></li><li>Писать некоторые тесты в nose-стиле (т.е. assert'ами, а не используя
xUnit API). Это не потому, что мне не нравится xUnit API, а потому что
кое-какие тесты проще писать и поддерживать именно в nose-стиле.</li><li>Первые два пункта были критическими, а этот пункт опциональным: по возможности дать привязки к twill (меня больше интересовал вопрос
автоматического обхода набора twill-тестов, чем Django-интеграция
и улучшенный API для twill'а).</li></ol>
<p>Так вот, <i>ни один</i> из просмотренных инструментов не подходил под требования
пункта 1. Т.е. стандартный джанговский test runner нормально запускал тесты,
я переключался на альтернативный test runner, и тот не видел половину тестов.</p><p>Немного проясню причины. Дело в том, что стандартный <code>django.test.simple.run_tests</code> обходит все установленные приложения и ищет тесты в оговоренных местах: в модуле моделей и в модуле/пакете <code>&lt;app&gt;.tests</code>. Все рассмотренные здесь инструменты используют поиск тестов средствами nose. Таким образом, если у вас есть проект и подключены приложения вне дерева кода этого проекта, то джанговский test runner их запускает, а nose test discovering их не находит.</p><p>Поэтому я взял наиболее простой django-satprep и <a href="http://bitbucket.org/j2a/django_satprep/">адаптировал его</a>
под мои требования. Пункт 2 выполнился автоматически, а в качестве бонуса
nose ловит тесты в тест-пакете, которые и не перечислены в <code>__init__.py</code> внутри <code>&lt;app&gt;.tests</code>. По правде сказать, адаптация не даёт мне чувства законченности и у нее есть неизящные решения, наследованные от satprep (например, опции для nose передаются в виде <code>python manage.py test -- -vds</code>), но она удовлетворяет текущим требованиям, а дальше будет видно, то ли переключаться на NoseDjango, то ли дальше "дотачивать" свой форк satprep.</p>
<p>А про twill подробнее я расскажу в другой раз ;)</p>
{% endmark %}
