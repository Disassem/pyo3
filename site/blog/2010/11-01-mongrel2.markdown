{% meta %}
   tags: [mongrel, wsgi, deploy, zeromq]
   title: Mongrel2
{% endmeta %}

{% mark body %}{% filter markdown %}
Если бы не [Александр Соловьев][piranha], то я бы прошел мимо
[Mongrel2][mongrel2]. А всё потому, что первый [Mongrel][mongrel] был
Ruby-специфичным инструментом и никогда особо меня не интересовал.

Другое дело Mongrel2. Во-первых, он написан на C. Во-вторых, он не привязан
ни к какому из языков. В-третьих, он использует [ZeroMQ][zeromq] как транспорт.

По сути, Mongrel2 это балансирующий прокси, который парсит http и
отдает запросы в виде сообщений в ZeroMQ и так же получает ответы.

Mongrel2 интересен несколькими моментами.


**Быстрый.** Все операции по парсингу http (сам Mongrel2) и передачи
сообщений (ZeroMQ) берет на себя быстрый C-код.


**Не привязан к языкам** По сути, всё что вам нужно, чтобы начать работать с
mongrel - это биндинг к ZeroMQ, которые есть для всех более-менее мажорных
языков. Так что используя любой язык для работы с Mongrel (Erlang, Python,
Ruby, Lua), вы уже получаете распарсенный запрос, причем с гарантией,
что не получите специфичных для данного языка багов. 


**Асинхронные сообщения** Это самая интересная фишка Mongrel2 и тут стоит
остановиться чуть подробнее.

Дело в том, что современные балансировщики нагрузки работают как сервисы
«переднего края», принимающие запросы, *и* как «командные центры», которые
опеределяют, какому бэкенду следует отправить данный запрос. Как следствие,
при добавлении бэкенда нужно донастраивать балансировщик.

Mongrel делает иначе — он принимает запрос и, ничего не зная о бэкендах и их
количестве, ставит запрос в очередь. Запрос из очереди берет тот бэкенд,
который освобождается первым.

Это действительно здорово, когда вы просто добавляете бэкенд и он сразу начинает
работать.

Бэкенд является демоном, который подписывается на определенные сообщения в 
ZeroMQ, при получении обрабатывает и по готовности ответа шлет другое сообщение,
на которое уже подписан Mongrel2. Если говорить о WSGI, то нужен коннектор между
Mongrel2/ZeroMQ и WSGI-приложением (он [вроде бы есть][mongrel-wsgi],
и даже [не в единственном экземпляре][mongrel-wsgi2], но код OMG-OMG).

**Итог**. У Mongrel2 интересная концепция и он обещает быть весьма полезным на практике.
Я бы не рискнул сейчас его ставить в продакшн, но вот поиграться — вполне.

P.S. А еще у Mongrel2 конфиг в SQLite :)

[piranha]: http://piranha.org.ua
[mongrel2]: http://mongrel2.org
[mongrel]: http://rubygems.org/gems/mongrel
[zeromq]: http://zeromq.org
[mongrel-wsgi]: http://github.com/berry/Mongrel2-WSGI-Handler
[mongrel-wsgi2]: http://github.com/TimothyFitz/mongrel2_wsgi

{% endfilter %}{% endmark %}
